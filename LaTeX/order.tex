\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{modifyRouteA}{modifyRouteA}
\SetKwFunction{modifyRouteB}{modifyRouteB}

\section{Order operator}

\subsection{Motivation}
\label{sec:motORDER}
The order operator gives the user the opportunity to provide the algorithm with route alternatives that satisfy his needs, from which the best can be found according to length.  In the context of a sequenced route query, the user can specify single, none or multiple categories out of a sequenced category list to be in a specific order. Then only these categories are found in the form of a sequenced route query (SRQ) while the others are inspected and  prioritized algorithmically. The query is responsible for finding the best route, based on length, out of all possible permutations of the category sequence.

Suppose that a user poses the following query: he wants the place he visits to be a restaurant, before and after that he wants to visit a bank and a pharmacy, but it is not important for him to visit one before the other. So the query only knows that restaurant must be visited second. The proposed approach in this chapter uses a modified PNE to generate an optimal result for this type of query.

\subsection{Problem definition} 
\label{sec:problemOrder}
First we need to define what an ORDER sequence is:\newline
\textbf{ORDER sequence:} An order sequence $ORDER = (i_1, i_2, ..., i_k)$, with $k \leq l$ and $1 \leq i_i \leq l$ is a sequence of indices in a category sequence $M_1 = (c_1, c_2, ..., c_l)$. They represent the categories at the given indices and indicate that these categories should remain in the given places in this category sequence $M$. The PoIs from categories, of which no indices are specified in the ORDER sequence can be placed at any other index from the remaining indices for the not ordered categories.

The order query is then defined as follows: \newline
\textbf{Order query:} Given a sequence of categories $M = (c_1, c_2, ..., c_l)$, a starting point $sp$ in ${\rm I\!R}^2$ and an ORDER sequence $ORDER = (i_1, i_2, ..., i_k)$, $Q(sp, M, ORDER)$ is a Route Query, which searches for the shortest (in terms of function $length$) sequenced route $R$ that follows partially $M$ as defined by the ORDER sequence.

%\subsection{Precomputations} 
%\label{sec:precompOrder}
%The precomputations are the same as for the order operator in Section \ref{sec:precompEO}.

% Introducing the proposed algorithm + proving the correctness
\subsection{Proposed approach} 
\label{sec:approachOrder}
The order operator is designed using the PNE approach, proposed in \cite{OSR}. It keeps a sequence of the not ordered categories, which is the complement of the ORDER sequence: $NOTORDERED = \overline{ORDER}$, and inspects progressively each category option for the indices out of the NOTORDERED sequence, compares them and continues with the best one, based on length, until it reaches a full sequenced route. For the categories, the indices of which are in the ordered list, the algorithm finds them according to PNE. 
The NOTORDERED sequence is accordingly updated for every PSR, as it is specific to a route. Each time a PSR is build with one of the not ordered categories, it is removed from the NOTORDERED sequence for this specific route.

% Explaining the algorithm step by step
\subsubsection{Algorithm}
\label{sec:algortihmOrder}
The algorithm (shown in \ref{alg:order}) starts by initializing the heap, ordered by the length of the routes, and the NOTORDERED sequence, which is simply the complement of the ordered category list (line 1, 2). For building the first PSR (line 3 to 14), the algorithm checks if the first index is contained in the ORDER sequence and if that is the case it finds the nearest neighbor to the starting point from the first category, otherwise it builds partial routes with all possible categories for the first position, which are all the categories in the NOTORDERED list. From all these PSR the shortest one is chosen and put on the heap. It then proceeds to inspect and modify the routes on the heap based on their length, until a SR is reached. 

The algorithm proceeds with examining the routes on the heap by size and modifying them according to PNE. When the current route on the heap is a full SR, then the optimal route has been found. When the current route on the heap is a full SR, where $s = l$, then the optimal route has been found (line 18 to 21). Otherwise the algorithm modifies the current PSR according to cases a) and b) as in the PNE algorithm \ref{alg:PNE} (line 22 to 27). \newline

\begin{algorithm}[H]
	\label{alg:order}
	\caption{orderOperator}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$(sp, M = (c_1, c_2, ..., c_l), ORDER = (i_1, i_2, ..., i_k))$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$\;
	$initialize$ $NOTORDERED = \overline{ORDER}$\;
	
	\BlankLine
	
	\eIf{$ORDER$ contains 1}{
		$firstPSR =$\NN{$sp, U_{M_{1}}$}\;
	}{
		\ForEach(Finding all the possible neighbors to the starting point){$i$ in $NOTORDERED$}{
			
			$initialize$ $shortestPSR$\;
			\tcp{Building a new $PSR$ with $c_i$}
			\NN{$sp, U_{M_{i}}$}\;
			$update$ $shortestPSR$\;	
		}
	
		$firstPSR \leftarrow shortestPSR$\;

	}
	place $firstPSR$ on heap\;
	
	
	\BlankLine
	
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length and it is checked}
	
	fetch a $PSR$ from the $heap$\;
	\Switch{$s = size(current)$}{
		\Case{$s == l$}{
			$PSR$ is the optimal route\;
			\Return $PSR$\;
		}
		\Case{$s \neq l$}{
			\tcp{a)}
			\modifyRouteA{$PSR$}\;
			
			\tcp{b)}
			\modifyRouteB{$PSR$}\;
		}
	}

\end{algorithm}

\pagebreak

In case a) \ref{proc:mRouteA} it is checked if the category to be found next is part of the ORDER sequence. If this is the case it finds the nearest neighbor to the last PoI in the current PSR $r_{s-1}$ from the category set $U_{M_{s}}$, otherwise it finds all nearest neighbors to $r_{s-1}$ from the categories in the NOTORDERED list $M_{i}$ and builds multiple partial routes, which are then compared and the shortest one is chosen and put on the heap.
Trimming is also performed (see \ref{proc:trim}).

\begin{procedure}[H]
	\label{proc:mRouteA}
	\caption{modifyRouteA($PSR$)}

	\eIf{$ORDER$ contains $s$}{
		$newPSR =$\NN{$r_{s-1}, U_{M_{s}}$}\;
	}{
		\ForEach(Finding all the possible neighbors out of the remaining categories in the not ordered list){$i$ in $NOTORDERED$}{
			
			$initialize$ $shortestPSR$\;
			\tcp{Building a new $PSR$ with $c_{i}$}
			\NN{$r_{s-1}, U_{M_{i}}$}\;
			$update$ $shortestPSR$\;	
		}
		
		$newPSR \leftarrow shortestPSR$\;
		update $PSR.NOTORDERED$\;
	}

	\tcp{Trimming is also done (see \ref{proc:trim})}
	place $newPSR$ on heap\;
\end{procedure}


In case b) \ref{proc:mRouteB} an alternative PSR with the kth nearest neighbor to $r_{s-2}$ is found. The algorithm checks again if the category to be found next is part of the ORDER sequence. If this is the case it simply finds the kth nearest neighbor to $r_{s-2}$ from the category set $U_{M_{s-1}}$, otherwise it finds all nearest neighbors to $r_{s-2}$ from the categories in the NOTORDERED list $M_{i}$ and builds multiple partial routes, which are then compared and the shortest one is chosen and put on the heap. \newline

\begin{procedure}[H]
	\label{proc:mRouteB}
	\caption{modifyRouteB($PSR$)}
	
	\eIf{$ORDER$ contains $s-1$}{
		$newPSR =$\KNN{$r_{s-2}, U_{M_{s-1}}$}\;
	}{
		\ForEach(Finding all the possible neighbors out of the remaining categories in the not ordered list){$i$ in $NOTORDERED$}{
			
			$initialize$ $shortestPSR$\;
			\tcp{Building a new $PSR$ with $c_{i-1}$}
			\KNN{$r_{s-2}, U_{M_{i-1}}$}\;
			$update$ $shortestPSR$\;	
		}
		
		$newPSR \leftarrow shortestPSR$\;
		update $PSR.NOTORDERED$\;
	}

	place $newPSR$ on heap\;
\end{procedure}

\subsubsection{Running example}
We describe the algorithm for the order operator using the example in Section \ref{sec:motORDER}, using the road network in Figure \ref{fig:example}. The user wanted to visit the restaurant at seond place in his route and also visit a bank and a pharmacy (i.e., $M = (b, r, ph)$, $|M| = l = 3$, $ORDER = (1)$). In Figure \ref{heapORDER} the partial routes stored in the $heap$ in each step of the algorithm are displayed.
First, the $notordered$ list is initiated: $[b, ph]$. Since the first position of the category sequence in the query is not fixed, routes from the starting point $sp$ with both categories in the $notordered$ list are generated: $b_1$ with length 2 and $ph_1$ with length 3. Route $b_1$ is shorter and is therefore placed on the heap. In step one, we have the case, where the searched PoI is at a fixed position 1. In this case in a) the nearest neighbor to $b_1$ from type restaurant $r_2$ is found, while in b) the next nearest neighbor to the starting point types bank and pharmacy are found and compared again. In step 5 the first SR $(ph_1, r_1, b_1)$ with length 8 is generated and placed as a candidate route on the heap.

This process continues until in step 11 the optimal route $(ph_2, r_2, b_2)$ with length 6 is returned.

\begin{table}[h]
	\centering
	\begin{tabular}{ |l|p{14cm}| } 
		\hline
		Step & PSR $R : length(r), r.notordered$ \\
		\hline
		1 & $(b_1 : 2, [ph])$ \\ 
		\hline
		2 & $(ph_1 : 3, [b]), (b_1, r_2 : 5, [ph])$ \\ 
		\hline
		3 & $(ph_2 : 3, [b]), (ph_1, r_1 : 5, [b]), (b_1, r_2 : 5, [ph])$ \\ 
		\hline
		4 & $(b_2 : 4, [ph]), (ph_2, r_2 : 5, [b]), (ph_1, r_1 : 5, [b]), (b_1, r_2 : 5, [ph])$ \\ 
		\hline
		5 & $(ph_1, r_1 : 5, [b]), (b_2, r_2 : 5, [ph]), (ph_2, r_2 : 5, [b]), (b_1, r_2 : 5, [ph])$ \\ 
		\hline
		6 & $(b_2, r_2 : 5, [ph]), (ph_2, r_2 : 5, [b]), (b_1, r_2 : 5, [ph]), (ph_1, r_1, b_1 : 8, [])$ \\ 
		\hline
		7 & $(b_1, r_2 : 5, [ph]), (b_2, r_2, ph : 5, [ph]), (ph_2, r_2 : 5, [b]), (b_2, r_2, ph_2 : 7, []),$ \st{$(ph_1, r_1, b_1 : 8, [])$} $, (b_2, r_1 : 9, [ph]), (ph_1, r_2 : 10, [b])$ \\ 
		\hline
		8 & $(b_2, r_2 : 5, [ph]), (ph_2, r_2 : 5, [b]), (b_1, r_1 : 5, [ph]), (b_2, r_2, ph_2 : 7, []), $ \st{$(b_1, r_2, ph_2 : 7, [])$} $, (b_2, r_1 : 9, [ph]), (ph_1, r_2 : 10, [b])$ \\ 
		\hline
		9 & $(b_1, r_1 : 5, [ph]), (b_2, r_2 : 5, [ph]), (ph_2, r_2, b_2 : 6, []),$ \st{$(b_2, r_2, ph_2 : 7, [])$} $, (ph_2, r_1 :7, [b]), (b_2, r_1 : 9, [ph]), (ph_1, r_2 : 10, [b])$ \\ 
		\hline
		10 & $(b_2, r_2 : 5, [ph]), (ph_2, r_2, b_2 : 6, []),$ \st{$(b_1, r_1, ph_1 : 7, [])$} $, (ph_2, r_1 :7, [b]), (b_2, r_1 : 9, [ph]), (ph_1, r_2 : 10, [b])$ \\ 
		\hline
		11 & $(ph_2, r_2, b_2 : 6, []), (ph_2, r_1 :7, [b]), (b_2, r_1 : 9, [ph]), (ph_1, r_2 : 10, [b])$ \\ 
		\hline
	\end{tabular}
	\caption{Steps of the algorithm for ORDER using the road network from Figure \ref{fig:example}}
	\label{heapORDER}
\end{table}

\subsection{Baseline approach} 
\label{sec:baselineOrder}
A naive solution, similar to the one with the order operator in Chapter \ref{sec:baselineOr}, to find an optimal route with the order operator would be to run the PNE algorithm on all possible permutations of the query and to find the shortest route out of all. This is known as the baseline approach.

% Proving the correctness and comparing to the baseline/trivial approach
\subsubsection{Correctness}
\label{sec:correctnessOrder}
\todo[color=yellow!40]{Todo: Correctness}

