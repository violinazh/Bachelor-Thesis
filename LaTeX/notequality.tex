\section{Not-Equality operator}
The equality operator is based on the need to express that some PoIs in the SRQ of the same category shouldn't be equal.

\subsection{Problem definition} 
\label{sec:problem}
The not-equality operator is defined as follows: \newline

\textbf{Not-Equality operator:} Given a sequence of categories $M = (c_1, c_2, ..., c_l)$, a starting point $sp$ in ${\rm I\!R}^2$ and indices $i$ and $j$, , where $r_i \in U_{M_{i}}$, $r_j \in U_{M_{j}}$ and $M_i \neq M_j$, $NOTEQUAL(i, j)$ is an equality operator, which states that $r_i$ and $r_j$ in the found route $R = (r_1, r_2, ..., r_l)$ should be different points of interest.
$Q(sp, M, NOTEQUAL(i, j))$ is a Sequenced Route (SR) Query, which searches for the shortest (in terms of function $length$) sequenced route $R$ that follows $M$ and where $r_i \neq r_j$.

\subsection{Precomputations} 
\label{sec:precomp}

% Introducing the proposed algorithm + proving the correctness
\subsection{Proposed approach} 
\label{sec:approach}
The not-equality operator is designed using the PNE approach, proposed in \cite{OSR}. It uses the progressive neighbour explorator as its base to upgrade on and explore all the possible optimal routes until it finds an optimal route, in which the given PoIs are different.

% Explaining the algorithm step by step
\subsubsection{Algorithm}
\label{sec:algortihm}

\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{travelDistance}{travelDistance}
\SetKwFunction{length}{length}

\begin{algorithm}
	\label{notequality}
	\caption{notEqualityOperator}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$(sp, M = (c_1, c_2, ..., c_l)), NOTEQUAL(i, j)$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$\; 
	
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length and it is checked}
	
	fetch a $PSR$ from the $heap$\;
	\While{$heap$ is not empty}{
		\eIf{$length(PSR) = l$}{
			\eIf{$PSR[i] \neq PSR[j]$}{
				$PSR$ is the optimal route\;
			}
			{
				\tcp{We continue}
			}
		}
		{
			a) \NN{$r_|PSR|, U_{m_{|PSR|+1}}$}\;
			update $PSR$ and put it back on the $heap$\;
			b) \KNN{$r_{|PSR|-1}, U_{m_|PSR|}$}\;
			generate a new $PSR$ and place it on the $heap$\;
		}
	}
	
	
\end{algorithm}

% Proving the correctness and comparing to the baseline/trivial approach
\subsubsection{Correctness}
\label{sec:correctness}

% Performance of the algorithm
\subsection{Experimental study}
\label{sec:experiments}