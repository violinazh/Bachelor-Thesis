\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{travelDistance}{travelDistance}
\SetKwFunction{length}{length}
\SetKwFunction{trim}{trim}

\section{Not-Equality operator}
The not-equality operator is based on the need to express that some PoIs in the SRQ of the same category shouldn't be equal.

\subsection{Problem definition} 
\label{sec:problemNEO}
The not-equality operator is defined as follows: \newline

\textbf{Not-Equality operator:} Given a sequence of categories $M = (c_1, c_2, ..., c_l)$, a starting point $sp$ in ${\rm I\!R}^2$ and indices $i$ and $j$, , where $r_i \in U_{M_{i}}$, $r_j \in U_{M_{j}}$ and $M_i \neq M_j$, $NOTEQUAL(i, j)$ is an equality operator, which states that $r_i$ and $r_j$ in the found route $R = (r_1, r_2, ..., r_l)$ should be different points of interest.
$Q(sp, M, NOTEQUAL(i, j))$ is a Sequenced Route (SR) Query, which searches for the shortest (in terms of function $length$) sequenced route $R$ that follows $M$ and where $r_i \neq r_j$.

\subsection{Precomputations} 
\label{sec:precompNEO}
The precomputations are the same as for the not equality operator in Section \ref{sec:precompEO}.

% Introducing the proposed algorithm + proving the correctness
\subsection{Proposed approach} 
\label{sec:approachNEO}
The not-equality operator is designed using the PNE approach, proposed in \cite{OSR}. It uses the progressive neighbour explorator as its base to upgrade on and explore all the possible optimal routes until it finds an optimal route, in which the given PoIs are different.

% Explaining the algorithm step by step
\subsubsection{Algorithm}
\label{sec:algortihmNEO}
The algorithm (shown in \ref{alg:notequality}) starts by initializing the heap, ordered by the length of the routes, and the first PSR (line 1, 2, 3). It then proceeds to inspect and modify the routes on the heap based on their length, until a full SR is found (line 7 to 20). Each full SR (line 8 to 11) is checked if it is a full SR. If this is the case, the found optimal SR is returned, otherwise the next PSR on the heap is fetched. If the fetched PSR is not a full SR but a partial route (line 12 to 19), then the algorithm performs a) and b) as in the PNE algorithm \ref{alg:PNE}. \newline

\begin{algorithm}[H]
	\label{alg:notequality}
	\caption{notEqualityOperator}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$(sp, M = (c_1, c_2, ..., c_l)), NOTEQUAL(i, j)$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$\;
	$initialize$ $candidate$\;
	
	$firstPSR =$\NN{$sp, U_{M_{1}}$}\;
	place $firstPSR$ on heap\;
	
	\BlankLine
	
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length and it is checked}
	
	fetch a $PSR$ from the $heap$\;
	\Switch{$s = size(PSR)$}{
		\Case{$s == l$}{
			$PSR$ is the optimal route\;
			\Return $PSR$\;
		}
		\Case{$s \neq l$}{
			a) \NN{$r_{|PSR|}, U_{M_{|PSR|+1}}$}\;
			update $PSR$\;
			\trim{$PSR$}\;
			b) \KNN{$r_{|PSR|-1}, U_{M_{|PSR|}}$}\;
			generate a new $PSR$\;
			\trim{$PSR$}\;
			
		}
	}
	
\end{algorithm}

Each time a $PSR$ is generated the trim procedure \ref{proc:trim_NEO} is performed. It is checked if the generated $PSR$ is a full SR (line 1) and if that is the case (line 1 to 16) the routes gets further examined. In the case that the route satisfies the requirement for $i$ and $j$ to not be equal (line 2 to 8), its length is compared of that of the candidate route and if it is shorter or equal, the candidate route is updated and the sequenced route is placed on the $heap$. Otherwise (line 8 to 15) we check if $j$ is the last index in the route and in this case (line 10 to 14) the kth neighbor of the previous PoI to the last one is found and a new $PSR$ is generated. If the route doesn't satisfy the requirements for $i$ and $j$ to not be equal and $j$ to be last index, it is simply discarded as not possible SR.
If the generated route is still not a full SR (line 16 to 21) the $PSR$ is placed on the $heap$. \newline

\begin{procedure}[H]
	\label{proc:trim_NEO}
	\caption{trim($PSR$)}
	\eIf{$size(PSR) = l$}{
		\eIf{$PSR[i] \neq PSR[j]$}{
			\tcp{Optimization: length check}
			\If{$length(PSR) <= length(candidate)$}{
				update $candidate$\;
				place $PSR$ on the $heap$\;
			}
		}
		{
			\tcp{In case $j$ is the last index in the route, we find the kth neighbor of the previous PoI to the last one}
			\If{$size(PSR) = j + 1$}{
				\KNN{$r_{|PSR|-1}, U_{M_{|PSR|}}$}\;
				generate a new $PSR$\;
				\trim{$PSR$}\;
			}
		}
		
	}{
		\tcp{Optimization: length check}
		\If{$length(PSR) <= length(candidate)$}{
			place $PSR$ on the $heap$\;
		}
	}
\end{procedure}

% Proving the correctness and comparing to the baseline/trivial approach
\subsubsection{Correctness}
\label{sec:correctnessNEO}
\todo[color=yellow!40]{Todo: Correctness}

% Performance of the algorithm
\subsection{Experimental study}
\label{sec:experimentsNEO}
\todo[color=yellow!40]{Todo: Experiments}