\section{Equality operator}
The equality operator is based on the need to express that some PoIs in the SRQ of the same category can or should be equal, as given in the example in Chapter 1 \ref{sec:intro}

\subsection{Design} 
\label{sec:design}
The equality operator is designed using the PNE approach from \cite{OSR}. It uses the progressive neighbour explorator as  its base to upgrade on and extends it with a heuristic approach to shrink the search space. 

\subsection{Implementation}
\label{sec:implementation}

\subsection{Evaluation}
\label{sec:evaluation}

\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{travelDistance}{travelDistance}
\SetKwFunction{length}{length}

\SetKwFunction{modifiedPNE}{modifiedPNE}
\SetKwFunction{dummySR}{dummySR}
\SetKwFunction{max}{max}
\SetKwFunction{trim}{trim}
\SetKwFunction{caseOne}{case1}
\SetKwFunction{caseTwo}{case2}
\SetKwFunction{caseThree}{case3}
\SetKwFunction{caseFour}{case4}

\begin{algorithm}
	\caption{equalityOperator}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$Query(sp, M = (c_1, c_2, ..., c_n)), Equal(i, j)$}
	\Output{$Route = (r_1, r_2, ..., r_n)$}
	\BlankLine
	
	$initialize$ $heap$\; 
	$initialize$ $UB$\; 
	$optimalRoute =$\PNE{$Query$}\;
	\eIf{$optimalRoute[i] = optimalRoute[j]$}{
		optimal route has been found\;
		\Return $optimalRoute$\;
	}
	{
		\dummySR{}\;
		\modifiedPNE{}\;
	}
\end{algorithm}

\begin{procedure}
	\caption{dummySR($optimalRoute$)}
	$firstPSR \leftarrow (r_1, r_2, ..., r_{i-1})$\;
	\tcp{Creating a dummy SR (partial sequence route) from the found optimal route; replacing $r_j$ with $r_i$}
	$dummySR = (r_1, r_2, ..., r_{i-1}, r_i, ..., r_i)$ \tcp*{First part of the route}
	$dummySR \leftarrow add$ \PNE{$r_i, (c_{j+1}, ..., c_n)$}\;
	$UB =$ \length{$dummySR$}\;
	place $dummySR$ on the $heap$\;
\end{procedure}

\begin{algorithm}
	\caption{\protect\modifiedPNE returns Route}
	\lForEach{$r_i$ in $U_{M_i}$}{
		\tcp{Checking the upper bound for every $r_i$ (neighbor of $r_{i-1}$) in the category set $U_{M_i}$}
		build a new $PSR$ by adding $r_i$ to $firstPSR$\;
		$LB = \length{$PSR$} + \max{$r_i$}$\;
		\If{$LB <= UB$}{
			place the new $PSR$ $(r_1, ..., r_{i-1}, r_i)$ on the $heap$\;
			fetch a $PSR$ from the $heap$\;
			\Switch{$l = size(PSR)$}{
				\Case(Finding PSRs before $r_j$){$l <= j-1$}{
					\caseOne{}\;
				}
				\Case(Finding PSR containing $r_j$){$l = j$}{
					\caseTwo{}\;
				}
				\Case(Finding PSR after/containing $r_j$){$l = j+1$}{
					\caseThree{}\;
				}
				\Case(Finding PSRs after $r_j$){$l >= j+2$}{
					\caseFour{}\;
				}
				\Case(Optimal route with equal PoIs at $i$ and $j$ has been found){$l = m$}{
					\Return $SR$\;
				}
			}
			
		}
	}
	
\end{algorithm}

\begin{procedure}
	\caption{caseOne()}
	a) \NN{$r_k, U_{M_{k+1}}$}\;
	update $PSR$ to contain $r_{k+1}$\;
	$LB = \length{$PSR$} + \max{$r_{k+1}$}$\;
	\eIf{$LB <= UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	$LB = \length{$PSR$} + \max{$r_k$}$\;
	\eIf{$LB <= UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
\end{procedure}

\begin{procedure}
	\caption{caseTwo()}
	a) \travelDistance{$(r_{j-1}, r_i)$}\;
	update $PSR$ to contain $r_i$ in the place $j$\;
	$LB = \length{$PSR$} + \max{$r_j$}$\;
	\eIf{$LB <= UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
	b) \KNN{$r_{j-2}, U_{M_{j-1}}$}\;
	update $PSR$\;
	$LB = \length{$PSR$} + \max{$r_{j-1}$}$\;
	\eIf{$LB <= UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
\end{procedure}

\begin{procedure}
	\caption{caseThree()}
	a) \NN{$r_j, U_{M_{j+1}}$}\;
	update $PSR$ to contain $r_{j+1}$\;
	$LB = \length{$PSR$} + \max{$r_{j+1}$}$\;
	\eIf{$LB < UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
	b) \travelDistance{$(r_{j-1}, r_i)$}\;
	update $PSR$ to contain $r_i$ in the place $j$\;
	$LB = \length{$PSR$} + \max{$r_j$}$\;
	\eIf{$LB < UB$}{
		place $PSR$ on the $heap$\;
	}{
		\Break\;
	}
\end{procedure}

\begin{procedure}
	\caption{caseFour()}
	\tcp{Same procedure as caseOne() + trimming part to filter SR and update UB if needed}
	a) \NN{$r_k, U_{M_{k+1}}$}\;
	update $PSR$ to contain $r_{k+1}$\;
	$LB = \length{$PSR$} + \max{$r_{k+1}$}$\;
	\eIf{$LB <= UB$}{
		\tcp{Trimming part}
		\trim{$PSR$}\;
	}{
		\Break\;
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	$LB = \length{$PSR$} + \max{$r_k$}$\;
	\eIf{$LB <= UB$}{
		\tcp{Trimming part}
		\trim{$PSR$}\;
	}{
		\Break\;
	}
\end{procedure}

\begin{algorithm}
	\caption{\protect\PNE}
	\tcp{Incrementally create the set of candidate routes for $Query(sp, M)$ from starting point $sp$ towards PoI set $U_{M_m}$}
	\tcp{Candidate routes are stored in a heap sorted by length of the routes}
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length}
	\tcp{Trimming: There must be only one candidate SR on the heap}
	\Switch{$l = length(PSR)$}{
		\Case{$l = m$}{
			$PSR$ is the optimal route\;
		}
		\Case{$l \neq m$}{
			a) \NN{$r_|PSR|, U_{m_{|PSR|+1}}$}\;
			update $PSR$ and put it back on the $heap$\;
			b) \KNN{$r_{|PSR|-1}, U_{m_|PSR|}$}\;
			generate a new $PSR$ and place it on the $heap$\;
		}
	}
\end{algorithm}

\begin{procedure}
	\caption{max($r_k$)}
	\For(For all direct neighbors to $r_k$ of every subsequent category find the maximum distance){$c_{k+1}$ to $c_n$}{find maximum\;}
\end{procedure}

\begin{procedure}
	\caption{trim($PSR$)}
	\eIf{$size(PSR) = m$}{
		\tcp{Check if the length of the found SR is less than the one present on the heap - update the $UB$ and place $SR$ on the $heap$ if shorter}
	}{
		place $PSR$ on the $heap$\;
	}
\end{procedure}