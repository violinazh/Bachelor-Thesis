\section{Equality operator}
The equality operator is based on the need to express that some PoIs in the SRQ of the same category can or should be equal, as given in the example in Chapter \ref{sec:intro}.

\subsection{Problem definition} 
\label{sec:problem}
The equality operator is defined as follows: \newline

\textbf{Equality operator:} Given a sequence of categories $M = (c_1, c_2, ..., c_l)$, a starting point $sp$ in ${\rm I\!R}^2$ and indices $i$ and $j$, where $r_i \in U_{M_{i}}$, $r_j \in U_{M_{j}}$ and $M_i = M_j$, $EQUAL(i, j)$ is an equality operator, which states that $r_i$ and $r_j$ in the found route $R = (r_1, r_2, ..., r_l)$ should be the same points of interest.
$Q(sp, M, EQUAL(i, j))$ is a Sequenced Route (SR) Query, which searches for the shortest (in terms of function $length$) sequenced route $R$ that follows $M$ and where $r_i = r_j$.

\subsection{Precomputations} 
\label{sec:precomp}
% Table with first nearest neghbors of all categories to all crossroads nodes.
In order to faster calculate the heuristic for the partial routes, the nearest neighbors of all PoIs' categories to each node are precalculated and kept in a 2-dimensional table in memory for easy access. For precalculation a modified Dijkstra is executed for every node, which terminates as soon as it reaches the nearest neighbors of every category to a the given graph vertex.

\subsection{Heuristic approach} 
\label{sec:heuristic-approach}
The equality operator is designed using the PNE approach, proposed in \cite{OSR}. It uses the progressive neighbour explorator as its base to upgrade on and extends it with a heuristic approach to shrink the search space. \newline

For generating the routes and deciding which of them are worth further expanding on, the proposed approach uses an initially calculated upper bound of an artificially build OSR, which satisfies the equality condition, and compares it to a lower bound of a route, considered by the algorithm. The lower bound of a certain route represents the sum of its length and the maximum distance from the distances to PoIs from the set of categories that are yet to be expanded. This is the heuristic of a route. \ref{heuristic}

% Explaining the algorithm step by step
\subsubsection{Algorithm}
First, an optimal sequenced route is found using the PNE algorithm \ref{PNE}. It is checked, if the two PoIs that the user has asked to be equal, are equal in the OSR. If so, the OSR is returned, else the equality operator continues with the modified PNE algorithm.

Second, we artificially create a sequenced route from the optimal route, found by PNE, as seen in \ref{dummy}. The optimal route is changed, so that $r_j$ is made to be equal to $r_i$ and the length of the artificially created PSR is the initial upper bound, by which later partial sequenced routes are either kept or discarded.

The modified PNE algorithm \ref{mPNE} begins iterating all $r_1$ from the category set $U_{M_1}$, which are subsequent to $sp$ in the and it compares the lower bound, generated by them, to the global upper bound. They are only considered in further steps of the algorithm, if the partial sequenced route has a smaller lower bound than the upper bound.

Next, the modified PNE algorithm acts as a PNE algorithm and it fetches partial sequenced routes from the heap and generates new routes. There are four distinct cases depending on the length of the route and whether $c_j$ is to be further expanded. Case one \ref{c1} and four \ref{c4} follow the original PNE. Case two \ref{c2} is focused on finding the travel distance between $r_{j-1}$ and $r_i$.

\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{dist}{dist}
\SetKwFunction{length}{length}

\SetKwFunction{modifiedPNE}{modifiedPNE}
\SetKwFunction{dummySR}{dummySR}
\SetKwFunction{heuristic}{heuristic}
\SetKwFunction{trim}{trim}
\SetKwFunction{caseOne}{case1}
\SetKwFunction{caseTwo}{case2}
\SetKwFunction{caseThree}{case3}
\SetKwFunction{caseFour}{case4}

\begin{algorithm}
	\label{equality}
	\caption{equalityOperator}
	
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$Q(sp, M = (c_1, c_2, ..., c_l)), EQUAL(i, j)$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$\; 
	$initialize$ $UB$\; 
	$optimalRoute =$\PNE{$Q$}\;
	\eIf{$optimalRoute[i] = optimalRoute[j]$}{
		optimal route has been found\;
		\Return $optimalRoute$\;
	}
	{
		\dummySR{}\;
		\modifiedPNE{}\;
	}
\end{algorithm}

\begin{procedure}
	\label{dummy}
	\caption{dummySR($optimalRoute$)}
	
	\tcp{Creating a dummy SR (partial sequence route) from the found optimal route; replacing $r_j$ with $r_i$}
	$dummySR = (r_1, r_2, ..., r_{i-1}, r_i, ..., r_i)$ \tcp*{First part of the route}
	$dummySR \leftarrow add$ \PNE{$r_i, (c_{j+1}, ..., c_l)$}\;
	$UB =$ \length{$dummySR$}\;
	place $dummySR$ on the $heap$\;
\end{procedure}

\begin{algorithm}
	\label{mPNE}
	\caption{\protect\modifiedPNE returns Route}
	
	\ForEach(Checking the upper bound for every $r_1$ neighbor of $sp$ in the category set $U_{M_1}$){$r_1$ in $U_{M_1}$}{
		build a new $PSR$ with $r_1$\;
		$LB = \length{$PSR$} + \heuristic{$PSR$}$\;
		\If{$LB <= UB$}{
			place the new $PSR$ $(r_1)$ on the $heap$\;	
		}
	}
	$current$ = fetch a $PSR$ from the $heap$\;
	\Switch{$s = size(current)$}{
		\Case(Finding PSRs before $r_j$){$s <= j-1$}{
			\caseOne{}\;
		}
		\Case(Finding PSR containing $r_j$){$s = j$}{
			\caseTwo{}\;
		}
		\Case(Finding PSR after/containing $r_j$){$s = j+1$}{
			\caseThree{}\;
		}
		\Case(Finding PSRs after $r_j$){$s >= j+2$}{
			\caseFour{}\;
		}
		\Case(Optimal route with equal PoIs at $i$ and $j$ has been found){$s == l$}{
			\Return $current$\;
		}
	}
	
\end{algorithm}

\begin{procedure}
	\label{c1}
	\caption{caseOne()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \NN{$r_k, U_{M_{k+1}}$}\;
		update $PSR$ to contain $r_{k+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			place $PSR$ on the $heap$\;
		}
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}	
\end{procedure}

\begin{procedure}
	\label{c2}
	\caption{caseTwo()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \dist{$r_{j-1}, r_i$}\;
		update $PSR$ to contain $r_i$ in the place $j$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}
	b) \KNN{$r_{j-2}, U_{M_{j-1}}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}
\end{procedure}

\begin{procedure}
	\label{c3}
	\caption{caseThree()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB < UB$}{
		a) \NN{$r_j, U_{M_{j+1}}$}\;
		update $PSR$ to contain $r_{j+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}	
	b) \tcp{Found in caseTwo}
\end{procedure}

\begin{procedure}
	\label{c4}
	\caption{caseFour()}
	
	\tcp{Same procedure as caseOne() + trimming part to filter SR and update UB if needed}
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \NN{$r_k, U_{M_{k+1}}$}\;
		update $PSR$ to contain $r_{k+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}	
\end{procedure}

\begin{algorithm}
	\label{PNE}
	\caption{\protect\PNE}
	\tcp{Incrementally create the set of candidate routes for $Q(sp, M)$ from starting point $sp$ towards PoI set $U_{M_l}$}
	\tcp{Candidate routes are stored in a heap sorted by length of the routes}
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length}
	\tcp{Trimming: There must be only one candidate SR on the heap}
	\Switch{$s = size(PSR)$}{
		\Case{$s == l$}{
			$PSR$ is the optimal route\;
		}
		\Case{$l \neq m$}{
			a) \NN{$r_{|PSR|}, U_{M_{|PSR|+1}}$}\;
			update $PSR$ and put it back on the $heap$\;
			b) \KNN{$r_{|PSR|-1}, U_{M_{|PSR|}}$}\;
			generate a new $PSR$ and place it on the $heap$\;
		}
	}
\end{algorithm}

\begin{procedure}
	\label{heuristic}
	\caption{heuristic($R$)}
	\tcp{Calculates the heuristic for the given route $R = (r_1, r_2, ..., r_k)$}
	\tcp{For every route, which already contains $r_i$ $R = (r_1, r_2, ...,r_i, ..., r_k)$ the distance to $r_j$ is calculated as the \dist{$r_k, r_i$}}
	\For(For all direct neighbors to $r_k$ of every subsequent category find the maximum distance){$c_{k+1}$ to $c_n$}{find maximum\;}
\end{procedure}

\begin{procedure}
	\label{trim}
	\caption{trim($PSR$)}
	\eIf{$size(PSR) = m$}{
		\tcp{Check if the length of the found SR is less than the one present on the heap - update the $UB$ and place $SR$ on the $heap$ if shorter}
	}{
		place $PSR$ on the $heap$\;
	}
\end{procedure}

\subsubsection{Correctness}


% Introducing the proposed algorithm + proving the correctness
\subsection{Proposed approach} 
\label{sec:approach}

% Explaining the algorithm step by step
\subsubsection{Algorithm}

% Proving the correctness and comparing to the baseline/trivial approach
\subsubsection{Correctness}


% Performance of the algorithm
\subsection{Experimental study}
\label{sec:experiments}