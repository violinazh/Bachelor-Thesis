\SetKw{Return}{return}
\SetKw{Break}{break}

\SetKwFunction{PNE}{PNE}
\SetKwFunction{NN}{nearestNeigbour}
\SetKwFunction{KNN}{kNearestNeigbour}
\SetKwFunction{dist}{dist}
\SetKwFunction{length}{length}

\SetKwFunction{modifiedPNE}{modifiedPNE}
\SetKwFunction{modifiedPNE-baseline}{modifiedPNE-baseline}
\SetKwFunction{dummySR}{dummySR}
\SetKwFunction{heuristic}{heuristic}
\SetKwFunction{trim}{trim}
\SetKwFunction{caseOne}{case1}
\SetKwFunction{caseTwo}{case2}
\SetKwFunction{caseThree}{case3}
\SetKwFunction{caseFour}{case4}

\section{Equality operator}
The equality operator is based on the need to express that some PoIs in the SRQ of the same category can or should be equal, as given in the example in Chapter \ref{sec:intro}.

\subsection{Problem definition} 
\label{sec:problemEO}
The equality operator is defined as follows: \newline

\textbf{Equality operator:} Given a sequence of categories $M = (c_1, c_2, ..., c_l)$, a starting point $sp$ in ${\rm I\!R}^2$ and indices $i$ and $j$, where $r_i \in U_{M_{i}}$, $r_j \in U_{M_{j}}$ and $M_i = M_j$, $EQUAL(i, j)$ is an equality operator, which states that $r_i$ and $r_j$ in the found route $R = (r_1, r_2, ..., r_l)$ should be the same points of interest.
$Q(sp, M, EQUAL(i, j))$ is a Sequenced Route (SR) Query, which searches for the shortest (in terms of function $length$) sequenced route $R$ that follows $M$ and where $r_i = r_j$.

\subsection{Precomputations} 
\label{sec:precompEO}
% Table with first nearest neghbors of all categories to all crossroads nodes.
In order to faster calculate the heuristic for the partial routes, the nearest neighbors of all PoIs' categories to each node are precalculated and kept in a 2-dimensional table in memory for easy access. For precalculation a modified Dijkstra is executed for every node, which terminates as soon as it reaches the nearest neighbors of every category to a the given graph vertex.

% Introducing the proposed algorithm + proving the correctness
\subsection{Proposed approach} 
\label{sec:approachEO}
The equality operator is designed using the PNE approach, proposed in \cite{OSR}. It uses the progressive neighbour explorator as its base to upgrade on and extends it with a heuristic approach to shrink the search space.

\subsubsection{Heuristic}
For generating the routes and deciding which of them are worth further expanding on, the proposed approach uses an initially calculated \textit{upper bound} of an artificially build OSR, which satisfies the equality condition, and compares it to a lower bound of a route, considered by the algorithm. The \textit{lower bound} of a certain route represents the sum of its length and its heuristic. The heuristic of a certain PSR is the maximum distance out of the distances to PoIs from the set of categories that are yet to be expanded.  \ref{proc:heuristic}

\begin{procedure}[H]
	\label{proc:heuristic}
	\caption{heuristic($R$)}
	\tcp{Calculates the heuristic for the given route $R = (r_1, r_2, ..., r_k)$}
	\tcp{For every route, which already contains $r_i$ $R = (r_1, r_2, ...,r_i, ..., r_k)$ the distance to $r_j$ is calculated as the \dist{$r_k, r_i$}}
	\For(For all direct neighbors to $r_k$ of every subsequent category find the maximum distance){$c_{k+1}$ to $c_n$}{find maximum\;}
\end{procedure}

% Explaining the algorithm step by step
\subsubsection{Algorithm}

The algorithm for the equality operator as shown in \ref{alg:equality} is constructed using multiple procedures.

\begin{algorithm}[H]
	\label{alg:equality}
	\caption{equalityOperator}
	
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$Q(sp, M = (c_1, c_2, ..., c_l)), EQUAL(i, j)$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$ \tcp*{Heap with PSR}
	$initialize$ $found$ \tcp*{The candidate SR}
	$initialize$ $UB$\; 
	$optimalRoute =$\PNE{$Q$}\;
	\eIf{$optimalRoute[i] = optimalRoute[j]$}{
		optimal route has been found\;
		\Return $optimalRoute$\;
	}
	{
		\dummySR{}\;
		\modifiedPNE{}\;
	}
\end{algorithm}

\pagebreak

In $heap$ the PSR which are to be examined by the algorithm are stored. It is sorted by lower bound of the PSR. $found$ stores a candidate SR. $UB$ is the length of the candidate route and it is updated each time a full SR is found The update is performed in $trim$ \ref{proc:trim}

First, an optimal sequenced route is found using the PNE algorithm \ref{alg:PNE}. It is checked, if the two PoIs that the user has asked to be equal, are equal in the OSR. If so, the OSR is returned, else the equality operator continues with the creation of an artificial SR  $dummySR$ and the modified PNE algorithm. 

Second, we artificially create a sequenced route from the optimal route, found by PNE, as seen in \ref{proc:dummy}. The optimal route is changed, so that $r_j$ is made to be equal to $r_i$ and the length of the artificially created PSR is the initial upper bound, by which later partial sequenced routes are either kept or discarded.

\begin{procedure}[H]
	\label{proc:dummy}
	\caption{dummySR($optimalRoute$)}
	
	\tcp{Creating a dummy SR (partial sequence route) from the found optimal route; replacing $r_j$ with $r_i$}
	$dummySR = (r_1, r_2, ..., r_{i-1}, r_i, ..., r_i)$ \tcp*{First part of the route}
	$dummySR \leftarrow add$ \PNE{$r_i, (c_{j+1}, ..., c_l)$}\;
	$UB =$ \length{$dummySR$}\;
	place $dummySR$ on the $heap$\;
\end{procedure}

The modified PNE algorithm \ref{alg:mPNE} begins iterating all $r_1$ from the category set $U_{M_1}$, which are subsequent to $sp$ in the and it compares the \textit{lower bound}, generated by them, to the global \textit{upper bound}. They are only considered in further steps of the algorithm, if the partial sequenced route has a smaller lower bound than the upper bound.\newline

\begin{algorithm}[H]
	\label{alg:mPNE}
	\caption{\protect\modifiedPNE returns Route}
	
	\ForEach(Checking the upper bound for every $r_1$ neighbor of $sp$ in the category set $U_{M_1}$){$r_1$ in $U_{M_1}$}{
		build a new $PSR$ with $r_1$\;
		$LB = \length{$PSR$} + \heuristic{$PSR$}$\;
		\If{$LB <= UB$}{
			place the new $PSR$ $(r_1)$ on the $heap$\;	
		}
	}
	
	\While{heap is not empty}{
		$current$ = fetch a $PSR$ from the $heap$\;
		\Switch{$s = size(current)$}{
			\Case(Finding PSRs before $r_j$){$s <= j-1$}{
				\caseOne{}\;
			}
			\Case(Finding PSR containing $r_j$){$s = j$}{
				\caseTwo{}\;
			}
			\Case(Finding PSR after/containing $r_j$){$s = j+1$}{
				\caseThree{}\;
			}
			\Case(Finding PSRs after $r_j$){$s >= j+2$}{
				\caseFour{}\;
			}
		}
	}
	
	\Return $found$
	
\end{algorithm}

\pagebreak

Next, the modified PNE algorithm acts as a PNE algorithm and it fetches partial sequenced routes from the heap and generates new routes. This process is repeated until the $heap$ runs out of PSR, which means that all possible candidate routes have been expanded and taken into account.

At each subsequent iteration of the algorithm \ref{alg:mPNE} (line 9 to 26) there are four distinct cases depending on the length of the route. Case one \ref{proc:c1} and four \ref{proc:c4} follow the original PNE. Case two \ref{proc:c2} is focused on finding the travel distance between $r_{j-1}$ and $r_i$. In each of the cases after fetching the route first the \textit{lower bound} of the fetched PSR is compared to the global \textit{upper bound} to see if the route should be modified or discarded (lines 1 to 3). After that the PSR is modified accordingly and again a length check is performed before finally putting the route on the $heap$. The length check is performed to make sure that the PSR is not longer than the already found SR with a length, which is the upper bound $UB$.  

In case one \ref{proc:c1} we find PSR before $r_j$. Two modifications of the PSR are performed, which follow the PNE algorithm \ref{alg:PNE}. In a) (line 4) the nearest neighbor to the last PoI in the PSR $r_k$ in $U_{M_{k+1}}$ is found and the PSR is updated to contain $r_{k+1}$ and placed back on the heap. In b) (line 11) the k-th nearest neighbor to the second to last PoI $r_{k+1}$ in $U_{M_{k}}$ is found and the last PoIs in the PSR $r_k$ is replaced with it.

\begin{procedure}[H]
	\label{proc:c1}
	\caption{caseOne()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \NN{$r_k, U_{M_{k+1}}$}\;
		update $PSR$ to contain $r_{k+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			place $PSR$ on the $heap$\;
		}
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}	
\end{procedure}

In case two \ref{proc:c2} $r_j$ is to be found. In a) (line 4) instead of finding the nearest neighbor like the PNE algorithm does, the travel distance between the last PoI in the PSR $r_{j-1}$ and $r_i$ is found, because we want $r_j$ to be equal to $r_i$ ind the route. In b) (line 12) the k-th nearest neighbor to the second to last PoI $r_{j-2}$ in $U_{M_{j-1}}$ is found and the last PoIs in the PSR $r_{j-1}$ is replaced with it.

\begin{procedure}[H]
	\label{proc:c2}
	\caption{caseTwo()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \dist{$r_{j-1}, r_i$}\;
		update $PSR$ to contain $r_i$ in the place $j$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}
	b) \KNN{$r_{j-2}, U_{M_{j-1}}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}
\end{procedure}

In case three \ref{proc:c3} $r_{j+1}$ is to be found. In a) (line 4) the nearest neighbor to the last PoI in the PSR $r_j$ in $U_{M_{j+1}}$ is found and the PSR is updated to contain $r_{j+1}$ and placed back on the heap. In b) (line 12) the k-th nearest neighbor to the second to last PoI $r_{j-1}$ in $U_{M_{j-2}}$ is expected to be found, but in our case this is $r_j$ and we have already calculated the travel distance between $r_{j-1}$ and $r_i$ in case two \ref{proc:c2}, so here nothing further needs to be done.

\begin{procedure}[H]
	\label{proc:c3}
	\caption{caseThree()}
	
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB < UB$}{
		a) \NN{$r_j, U_{M_{j+1}}$}\;
		update $PSR$ to contain $r_{j+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}	
	b) \tcp{Found in caseTwo}
\end{procedure}

\pagebreak

In case four \ref{proc:c4} we find PSR after $r_j$. The case is similar to case one \ref{proc:c1}, except that in a) instead of directly putting the PSR on the heap, trimming \ref{proc:trim} is performed to check if the route is a full SR and if the candidate route $found$ and the upper bound $UB$ must be updated (line 9). 

\begin{procedure}[H]
	\label{proc:c4}
	\caption{caseFour()}
	
	\tcp{Same procedure as caseOne() + trimming part to filter SR and update UB if needed}
	$LB = \length{$current$} + \heuristic{$current$}$\;
	\tcp{Heuristic check}
	\If{$LB <= UB$}{
		a) \NN{$r_k, U_{M_{k+1}}$}\;
		update $PSR$ to contain $r_{k+1}$\;
		\tcp{Length check}
		\If{$length(PSR) <= UB$}{
			\tcp{Trimming part}
			\trim{$PSR$}\;
		}
	}
	b) \KNN{$r_{k-1}, U_{M_k}$}\;
	update $PSR$\;
	\If{$length(PSR) <= UB$}{
		place $PSR$ on the $heap$\;
	}	
\end{procedure}

\pagebreak

\begin{algorithm}[H]
	\label{alg:PNE}
	\caption{\protect\PNE \cite{OSR}}
	\tcp{Incrementally create the set of candidate routes for $Q(sp, M)$ from starting point $sp$ towards PoI set $U_{M_l}$}
	\tcp{Candidate routes are stored in a heap sorted by length of the routes}
	\tcp{At each iteration of PNE a $PSR$ (partial sequenced route) is fetched and examined based on its length}
	\tcp{Trimming: There must be only one candidate SR on the heap}
	\Switch{$s = size(PSR)$}{
		\Case{$s == l$}{
			$PSR$ is the optimal route\;
			\Return $PSR$\;
		}
		\Case{$s \neq l$}{
			a) \NN{$r_{|PSR|}, U_{M_{|PSR|+1}}$}\;
			update $PSR$ and put it back on the $heap$\;
			b) \KNN{$r_{|PSR|-1}, U_{M_{|PSR|}}$}\;
			generate a new $PSR$ and place it on the $heap$\;
		}
	}
\end{algorithm}

\begin{procedure}[H]
	\label{proc:trim}
	\caption{trim($PSR$)}
	\eIf{$size(PSR) = l$}{
		\If{$length(PSR) <= UB$}{
			update $UB$\;
			update $found$\;
		}
	}{
		place $PSR$ on the $heap$\;
	}
\end{procedure}

% Proving the correctness and comparing to the baseline/trivial approach
\subsubsection{Correctness}
\todo[color=yellow!40]{Todo: Correctness}


\subsection{Baseline approach} 
\label{sec:baselineEO}
The baseline approach on the equality operator is entirely based on PNE by simply forcing $r_i$ and $r_j$ to be equal in the process of modifying the routes. In this variant, there is no heuristic and also no length checks.

% Explaining the algorithm step by step
\subsubsection{Algorithm}
The algorithm (shown in \ref{alg:equality_baseline}) starts by finding an optimal sequenced route with PNE, as mentioned in the proposed approach \ref{sec:approachEO} and checks if $r_i$ and $r_j$ are already equal. If this is the case, it returns the found optimal route, otherwise it continues with the modified PNE \ref{alg:mPNE_baseline}. 

\begin{algorithm}[H]
	\label{alg:equality_baseline}
	\caption{equalityOperator-baseline}
	
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	
	\Input{$Q(sp, M = (c_1, c_2, ..., c_l)), EQUAL(i, j)$}
	\Output{$R = (r_1, r_2, ..., r_l)$}
	\BlankLine
	
	$initialize$ $heap$ \tcp*{Heap with PSR}
	$optimalRoute =$\PNE{$Q$}\;
	\eIf{$optimalRoute[i] = optimalRoute[j]$}{
		optimal route has been found\;
		\Return $optimalRoute$\;
	}
	{
		\modifiedPNE-baseline{}\;
	}
\end{algorithm}

Modified PNE proceeds with examining the routes on the $heap$, ordered by length, by size and modifying them according to PNE. When the current route on the heap is a full SR, then the optimal route has been found. The four cases (line 5, 13, 21 and 27) correspond to the cases in algortihm of the proposed approach, with the only difference being that no heuristic and length checks are performed. \newline

\begin{algorithm}[H]
	\label{alg:mPNE_baseline}
	\caption{\protect\modifiedPNE-baseline returns Route}
	
	$firstPSR =$\NN{$sp, U_{M_{1}}$}\;
	place $firstPSR$ on heap\;
	
	$current$ = fetch a $PSR$ from the $heap$\;
	\Switch{$s = size(current)$}{
		\Case(Finding PSRs before $r_j$){$s <= j-1$}{
			a) \NN{$r_k, U_{M_{k+1}}$}\;
			update $PSR$ to contain $r_{k+1}$\;
			place $PSR$ on the $heap$\;
			b) \KNN{$r_{k-1}, U_{M_k}$}\;
			update $PSR$\;
			place $PSR$ on the $heap$\;
		}
		\Case(Finding PSR containing $r_j$){$s = j$}{
			a) \dist{$r_{j-1}, r_i$}\;
			update $PSR$ to contain $r_i$ in the place $j$\;
			\trim{$PSR$} \tcp*{Trimming part}
			b) \KNN{$r_{j-2}, U_{M_{j-1}}$}\;
			update $PSR$\;
			place $PSR$ on the $heap$\;
		}
		\Case(Finding PSR after/containing $r_j$){$s = j+1$}{
			a) \NN{$r_j, U_{M_{j+1}}$}\;
			update $PSR$ to contain $r_{j+1}$\;
			\trim{$PSR$} \tcp*{Trimming part}
			b) \tcp{Found in caseTwo}
		}
		\Case(Finding PSRs after $r_j$){$s >= j+2$}{
			a) \NN{$r_k, U_{M_{k+1}}$}\;
			update $PSR$ to contain $r_{k+1}$\;
			\trim{$PSR$} \tcp*{Trimming part}
			b) \KNN{$r_{k-1}, U_{M_k}$}\;
			update $PSR$\;
			place $PSR$ on the $heap$\;
		}
		\Case(Optimal route with equal PoIs at $i$ and $j$ has been found){$s == l$}{
			\Return $current$\;
		}
	}

	\Return $found$\;
	
\end{algorithm}

\subsubsection{Correctness}
\todo[color=yellow!40]{Todo: Correctness of baseline}
